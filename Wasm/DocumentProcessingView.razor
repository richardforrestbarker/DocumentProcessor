@namespace DocumentProcessor.Wasm.Components
@using System.Timers
@using System.Text.Json
@using System.IO
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using DocumentProcessor.Data.Ocr;
@using DocumentProcessor.Data.Ocr.Messages;
@using DocumentProcessor.Data.Messages;
@using Microsoft.Extensions.Logging

@inject IDocumentProcessor DocumentProcessingClient
@inject ILogger<DocumentProcessingView> Logger
@implements IDisposable

<style>
    .magnifier-container {
        position: relative;
        display: inline-block;
    }
    .magnifier-image {
        max-height: 500px;
        width: auto;
        height: auto;
        display: block;
    }
    .magnifier-lens {
        position: absolute;
        pointer-events: none;
        border: 2px solid rgba(0,0,0,0.2);
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        border-radius: 50%;
        width: 160px;
        height: 160px;
        background-repeat: no-repeat;
        background-position: center;
        background-size: 200%; /* zoom level */
        display: none;
        z-index: 10;
    }
</style>

<div class="document-processing-view">
    <h3>Document Processing Live View</h3>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger alert-dismissible fade show" role="alert">
            <strong>Error:</strong> @errorMessage
            <button type="button" class="btn-close" @onclick="() => errorMessage = null"></button>
        </div>
    }

    <!-- Phase Instructions -->
    <div class="alert alert-info">
        @switch (currentPhase)
        {
            case ProcessingPhase.Preprocessing:
                <span>
                    Preprocessing prepares the image for OCR by enhancing clarity and contrast.
                    Aim for a clean, high-contrast black-and-white result so text is crisp and readable.
                </span>
                break;
            case ProcessingPhase.Ocr:
                <span>
                    OCR extracts the raw, unstructured text from the image. Accuracy here is paramount because
                    downstream steps rely on correctly recognized characters and words.
                </span>
                break;
            case ProcessingPhase.Inference:
                <span>
                    Inference structures the extracted text into fields (like vendor, date, totals, line items)
                    so the computer can perform logic and automation reliably.
                </span>
                break;
        }
    </div>

    <div class="row">
        <!-- Left Panel: Source Image -->
        <div class="col-md-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>@(currentPhase == ProcessingPhase.Preprocessing ? "Source Image" : "Preprocessing Result")</span>
                    @if ((currentPhase == ProcessingPhase.Ocr || currentPhase == ProcessingPhase.Inference) && !string.IsNullOrEmpty(preprocessedImageBase64))
                    {
                        <span class="badge bg-success">Accepted</span>
                    }
                </div>
                <div class="card-body text-center">
                    @if (!string.IsNullOrEmpty(sourceImageBase64))
                    {
                        <div class="magnifier-container"
                             @onmousemove="(e) => OnMagnifierMove(e, true)"
                             @onmouseenter="() => ShowMagnifier(true)"
                             @onmouseleave="() => HideMagnifier(true)">
                            <img src="data:image/png;base64,@((currentPhase == ProcessingPhase.Ocr || currentPhase == ProcessingPhase.Inference) && !string.IsNullOrEmpty(preprocessedImageBase64) ? preprocessedImageBase64 : sourceImageBase64)"
                                 class="img-fluid magnifier-image"
                                 alt="@((currentPhase == ProcessingPhase.Ocr || currentPhase == ProcessingPhase.Inference) ? "Preprocessing Result" : "Source Image")"
                                 @ref="leftImageRef" />
                            <div class="magnifier-lens" style="@leftLensStyle"
                                 @ref="leftLensRef"></div>
                        </div>
                    }
                    else
                    {
                        <div class="text-muted p-5">
                            <i class="bi bi-image" style="font-size: 4rem;"></i>
                            <p>No image selected</p>
                            <InputFile OnChange="HandleFileSelection" accept="image/*" class="form-control" id="imageInput" />
                        </div>
                    }
                </div>
            </div>
        </div>

        <!-- Right Panel: Processing Result -->
        <div class="col-md-6">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span>
                        @switch (currentPhase)
                        {
                            case ProcessingPhase.Preprocessing:
                                <text>Preprocessing Result</text>
                                break;
                            case ProcessingPhase.Ocr:
                                <text>OCR Result</text>
                                break;
                            case ProcessingPhase.Inference:
                                <text>Inference Result</text>
                                break;
                        }
                    </span>
                    @if (isLoading)
                    {
                        <div class="d-flex align-items-center">
                            <div class="spinner-border spinner-border-sm text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            @if (!string.IsNullOrEmpty(currentJobId) && currentJobStatus != null)
                            {
                                <span class="ms-2 small text-muted">@currentJobStatus.Phase (@currentJobStatus.Progress%)</span>
                            }
                        </div>
                    }
                    else if (timerActive)
                    {
                        <!-- Timer Progress Circle -->
                        <div class="timer-progress" title="Updating in @timerSecondsRemaining seconds">
                            <svg width="24" height="24" viewBox="0 0 36 36">
                                <path d="M18 2.0845
                                        a 15.9155 15.9155 0 0 1 0 31.831
                                        a 15.9155 15.9155 0 0 1 0 -31.831"
                                      fill="none"
                                      stroke="#e0e0e0"
                                      stroke-width="3" />
                                <path d="M18 2.0845
                                        a 15.9155 15.9155 0 0 1 0 31.831
                                        a 15.9155 15.9155 0 0 1 0 -31.831"
                                      fill="none"
                                      stroke="#007bff"
                                      stroke-width="3"
                                      stroke-dasharray="@timerProgress, 100" />
                            </svg>
                            <span class="ms-1">@timerSecondsRemaining s</span>
                        </div>
                    }
                </div>
                <div class="card-body text-center">
                    @if (isLoading)
                    {
                        <div class="d-flex flex-column align-items-center justify-content-center h-100 p-5">
                            <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
                                <span class="visually-hidden">Processing...</span>
                            </div>
                            @if (currentJobStatus != null && !string.IsNullOrEmpty(currentJobStatus.Message))
                            {
                                <p class="mt-3 text-muted">@currentJobStatus.Message</p>
                            }
                            else
                            {
                                <p class="mt-3 text-muted">Processing image...</p>
                            }
                        </div>
                    }
                    else if (currentPhase == ProcessingPhase.Preprocessing && !string.IsNullOrEmpty(preprocessedImageBase64))
                    {
                        <div class="magnifier-container"
                             @onmousemove="(e) => OnMagnifierMove(e, false)"
                             @onmouseenter="() => ShowMagnifier(false)"
                             @onmouseleave="() => HideMagnifier(false)">
                            <img src="data:image/png;base64,@preprocessedImageBase64"
                                 class="img-fluid magnifier-image"
                                 alt="Preprocessed Image"
                                 @ref="rightImageRef" />
                            <div class="magnifier-lens" style="@rightLensStyle"
                                 @ref="rightLensRef"></div>
                        </div>
                    }
                    else if (currentPhase == ProcessingPhase.Ocr && ocrResult != null)
                    {
                        <div class="ocr-result text-start" style="max-height: 500px; overflow-y: auto;">
                            <h5>Extracted Text:</h5>
                            <pre class="bg-light p-3 rounded">@ocrResult.RawOcrText</pre>

                            @if (ocrResult.Words?.Count > 0)
                            {
                                <h6>Words detected: @ocrResult.Words.Count</h6>
                            }
                        </div>
                    }
                    else if (currentPhase == ProcessingPhase.Inference && inferenceResult != null)
                    {
                        <div class="inference-result text-start" style="max-height: 500px; overflow-y: auto;">
                            <h5>Extracted Fields:</h5>
                            <table class="table table-sm">
                                <tbody>
                                    @if (inferenceResult.VendorName != null)
                                    {
                                        <tr>
                                            <th>Vendor</th>
                                            <td>@inferenceResult.VendorName.Value</td>
                                        </tr>
                                    }
                                    @if (inferenceResult.Date != null)
                                    {
                                        <tr>
                                            <th>Date</th>
                                            <td>@inferenceResult.Date.Value</td>
                                        </tr>
                                    }
                                    @if (inferenceResult.TotalAmount != null)
                                    {
                                        <tr>
                                            <th>Total</th>
                                            <td>@inferenceResult.TotalAmount.Value</td>
                                        </tr>
                                    }
                                    @if (inferenceResult.Subtotal != null)
                                    {
                                        <tr>
                                            <th>Subtotal</th>
                                            <td>@inferenceResult.Subtotal.Value</td>
                                        </tr>
                                    }
                                    @if (inferenceResult.TaxAmount != null)
                                    {
                                        <tr>
                                            <th>Tax</th>
                                            <td>@inferenceResult.TaxAmount.Value</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                    }
                    else
                    {
                        <div class="text-muted p-5">
                            <i class="bi bi-gear" style="font-size: 4rem;"></i>
                            <p>Adjust settings and wait for preview</p>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <!-- Preprocessing Settings Panel -->
    @if (currentPhase == ProcessingPhase.Preprocessing)
    {
        <div class="card mt-4">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Preprocessing Settings</h5>
                @if (!string.IsNullOrEmpty(preprocessedImageBase64))
                {
                    <button class="btn btn-outline-secondary btn-sm" onclick="@ReplaceSourceWithPreprocessed" disabled="@isLoading">
                        <i class="bi bi-arrow-down-up me-1"></i>Replace source image with result
                    </button>
                }
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-12 mb-3 text-muted">
                        Aim for a clear, high-contrast black-and-white image. Deskew and denoise can help remove artifacts;
                        contrast settings enhance text legibility to improve OCR accuracy.
                    </div>
                    <div class="col-md-4">
                        <div class="form-check mb-3">
                            <InputCheckbox class="form-check-input" id="deskew"
                                   @bind-Value="settings.Deskew" @bind-Value:after="OnSettingsChanged" />
                            <label class="form-check-label" for="deskew">Deskew</label>
                        </div>
                        <div class="form-check mb-3">
                            <InputCheckbox class="form-check-input" id="denoise"
                                   @bind-Value="settings.Denoise" @bind-Value:after="OnSettingsChanged" />
                            <label class="form-check-label" for="denoise">Denoise</label>
                        </div>
                        <div class="form-check mb-3">
                            <InputCheckbox class="form-check-input" id="applyThreshold"
                                   @bind-Value="settings.ApplyThreshold" @bind-Value:after="OnSettingsChanged" />
                            <label class="form-check-label" for="applyThreshold">Apply Threshold</label>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="fuzzPercent" class="form-label">
                                Fuzz Percent: @settings.FuzzPercent %
                            </label>
                            <InputNumber type="range" class="form-range" id="fuzzPercent"
                                   min="0" max="100" step="5"
                                   @bind-Value="settings.FuzzPercent" @bind-Value:after="OnSettingsChanged" />
                        </div>
                        <div class="mb-3">
                            <label for="deskewThreshold" class="form-label">
                                Deskew Threshold: @settings.DeskewThreshold %
                            </label>
                            <InputNumber type="range" class="form-range" id="deskewThreshold"
                                   min="0" max="100" step="5"
                                   @bind-Value="settings.DeskewThreshold" @bind-Value:after="OnSettingsChanged" />
                        </div>
                        @if (settings.ApplyThreshold)
                        {
                            <div class="mb-3">
                                <label for="thresholdPercent" class="form-label">
                                    Threshold Percent: @settings.ThresholdPercent %
                                </label>
                                <InputNumber type="range" class="form-range" id="thresholdPercent"
                                       min="0" max="100" step="5"
                                       @bind-Value="settings.ThresholdPercent" @bind-Value:after="OnSettingsChanged" />
                            </div>
                        }
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="contrastType" class="form-label">Contrast Type</label>
                            <InputSelect class="form-select" id="contrastType"
                                    @bind-Value="settings.ContrastType" @bind-Value:after="OnSettingsChanged">
                                <option value="sigmoidal">Sigmoidal</option>
                                <option value="linear">Linear</option>
                                <option value="none">None</option>
                            </InputSelect>
                        </div>
                        @if (settings.ContrastType == "sigmoidal")
                        {
                            <div class="mb-3">
                                <label for="contrastStrength" class="form-label">
                                    Contrast Strength: @settings.ContrastStrength.ToString("F1")
                                </label>
                                <InputNumber type="range" class="form-range" id="contrastStrength"
                                       min="1" max="10" step="0.5"
                                       @bind-Value="settings.ContrastStrength" @bind-Value:after="OnSettingsChanged" />
                            </div>
                            <div class="mb-3">
                                <label for="contrastMidpoint" class="form-label">
                                    Contrast Midpoint: @settings.ContrastMidpoint %
                                </label>
                                <InputNumber type="range" class="form-range" id="contrastMidpoint"
                                       min="0" max="200" step="10"
                                       @bind-Value="settings.ContrastMidpoint" @bind-Value:after="OnSettingsChanged" />
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }

    <!-- OCR Settings Panel -->
    @if (currentPhase == ProcessingPhase.Ocr)
    {
        <div class="card mt-4">
            <div class="card-header">
                <h5 class="mb-0">OCR Settings</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-12 mb-3 text-muted">
                        OCR pulls text from the image. Higher DPI and a clean image improve recognition.
                        Choose the OCR engine appropriate for your environment; recognition quality is paramount.
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="ocrEngine" class="form-label">OCR Engine</label>
                            <InputSelect class="form-select" id="ocrEngine" @bind-Value="ocrSettings.OcrEngine">
                                <option value="tesseract">Tesseract</option>
                                <option value="paddle">PaddleOCR</option>
                            </InputSelect>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="targetDpi" class="form-label">Target DPI: @ocrSettings.TargetDpi</label>
                            <InputNumber type="range" class="form-range" id="targetDpi"
                                   min="72" max="600" step="50"
                                   @bind-Value="ocrSettings.TargetDpi" />
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="mb-3">
                            <label for="ocrDevice" class="form-label">Device</label>
                            <InputSelect class="form-select" id="ocrDevice" @bind-Value="ocrSettings.Device">
                                <option value="auto">Auto</option>
                                <option value="cpu">CPU</option>
                                <option value="cuda">CUDA</option>
                            </InputSelect>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }

    <!-- Inference Settings Panel -->
    @if (currentPhase == ProcessingPhase.Inference)
    {
        <div class="card mt-4">
            <div class="card-header">
                <h5 class="mb-0">Inference Settings</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-12 mb-3 text-muted">
                        Inference structures the OCR text into fields (e.g., vendor, date, totals, line items)
                        enabling reliable downstream automation and validation.
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="model" class="form-label">Model</label>
                            <InputSelect class="form-select" id="model" @bind-Value="inferenceSettings.Model">
                                <option value="naver-clova-ix/donut-base-finetuned-cord-v2">Donut (CORD-v2)</option>
                                <option value="HuggingFaceM4/idefics2-8b">IDEFICS2 (8B)</option>
                                <option value="phi-3-vision">Phi-3-Vision</option>
                                <option value="OpenGVLab/InternVL">InternVL</option>
                                <option value="Qwen/Qwen2-VL-7B-Instruct">Qwen2-VL (7B Instruct)</option>
                            </InputSelect>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="inferenceDevice" class="form-label">Device</label>
                            <InputSelect class="form-select" id="inferenceDevice" @bind-Value="inferenceSettings.Device">
                                <option value="auto">Auto</option>
                                <option value="cpu">CPU</option>
                                <option value="cuda">CUDA</option>
                            </InputSelect>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }

    <!-- Action Buttons -->
    <div class="d-flex justify-content-between mt-4">
        @if (currentPhase == ProcessingPhase.Ocr || currentPhase == ProcessingPhase.Inference)
        {
            <button class="btn btn-secondary" onclick="@GoBack" disabled="@isLoading">
                <i class="bi bi-arrow-left me-2"></i>Go Back
            </button>
        }
        else
        {
            <button class="btn btn-secondary" onclick="@Reset" disabled="@isLoading">
                <i class="bi bi-arrow-counterclockwise me-2"></i>Reset
            </button>
        }

        <div>
            @if (currentPhase == ProcessingPhase.Preprocessing && !string.IsNullOrEmpty(preprocessedImageBase64))
            {
                <button class="btn btn-primary" onclick="@AcceptPreprocessing" disabled="@isLoading">
                    Done - Continue to OCR<i class="bi bi-arrow-right ms-2"></i>
                </button>
            }
            else if (currentPhase == ProcessingPhase.Ocr)
            {
                @if (ocrResult != null)
                {
                    <button class="btn btn-secondary me-2" onclick="@RunOcr" disabled="@isLoading">
                        <i class="bi bi-arrow-repeat me-2"></i>Re-run OCR
                    </button>
                    <button class="btn btn-primary" onclick="@AcceptOcr" disabled="@isLoading">
                        Accept - Continue to Inference<i class="bi bi-arrow-right ms-2"></i>
                    </button>
                }
            }
            else if (currentPhase == ProcessingPhase.Inference)
            {
                @if (inferenceResult != null)
                {
                    <button class="btn btn-secondary me-2" onclick="@RunInference" disabled="@isLoading">
                        <i class="bi bi-arrow-repeat me-2"></i>Re-run Inference
                    </button>
                    <button class="btn btn-success" onclick="@AcceptResult">
                        <i class="bi bi-check-lg me-2"></i>Accept Result
                    </button>
                }
            }
        </div>
    </div>
</div>

@code {
    /// <summary>
    /// Event callback when the user accepts the final OCR result.
    /// </summary>
    [Parameter]
    public EventCallback<InferenceResult> OnResultAccepted { get; set; }

    /// <summary>
    /// Event callback when preprocessing starts.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnPreprocessingStarted { get; set; }

    /// <summary>
    /// Event callback when preprocessing completes.
    /// </summary>
    [Parameter]
    public EventCallback<PreprocessingResult> OnPreprocessingCompleted { get; set; }

    /// <summary>
    /// Event callback when OCR starts.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnOcrStarted { get; set; }

    /// <summary>
    /// Event callback when OCR completes.
    /// </summary>
    [Parameter]
    public EventCallback<OcrResult> OnOcrCompleted { get; set; }

    /// <summary>
    /// Event callback when inference starts.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnInferenceStarted { get; set; }

    /// <summary>
    /// Event callback when inference completes.
    /// </summary>
    [Parameter]
    public EventCallback<InferenceResult> OnInferenceCompleted { get; set; }

    /// <summary>
    /// Event callback when job status is updated.
    /// </summary>
    [Parameter]
    public EventCallback<JobStatus> OnJobStatusChanged { get; set; }

    /// <summary>
    /// Event callback when an error occurs.
    /// </summary>
    [Parameter]
    public EventCallback<string> OnError { get; set; }

    /// <summary>
    /// Optional initial image as base64.
    /// </summary>
    [Parameter]
    public string? InitialImageBase64 { get; set; }

    private enum ProcessingPhase
    {
        Preprocessing,
        Ocr,
        Inference
    }

    private ProcessingPhase currentPhase = ProcessingPhase.Preprocessing;
    private string? sourceImageBase64;
    private string? preprocessedImageBase64;
    private string? errorMessage;
    private bool isLoading;
    private bool timerActive;
    private int timerSecondsRemaining = 5;
    private double timerProgress = 100;
    private string? currentJobId;
    private JobStatus? currentJobStatus;

    private PreprocessingSettings settings = new();
    private OcrSettings ocrSettings = new();
    private InferenceSettings inferenceSettings = new();
    private OcrResult? ocrResult;
    private InferenceResult? inferenceResult;

    private System.Timers.Timer? updateTimer;
    private System.Timers.Timer? progressTimer;
    private System.Timers.Timer? statusPollTimer;
    private DateTime lastSettingsChange;

    // Magnifier state
    private ElementReference leftImageRef;
    private ElementReference rightImageRef;
    private ElementReference leftLensRef;
    private ElementReference rightLensRef;
    private bool leftLensVisible;
    private bool rightLensVisible;

    protected override void OnInitialized()
    {
        if (!string.IsNullOrEmpty(InitialImageBase64))
        {
            sourceImageBase64 = InitialImageBase64;
            OnSettingsChanged();
        }
    }

    protected override void OnParametersSet()
    {
        if (!string.IsNullOrEmpty(InitialImageBase64) && sourceImageBase64 != InitialImageBase64)
        {
            sourceImageBase64 = InitialImageBase64;
            OnSettingsChanged();
        }
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        errorMessage = null;

        try
        {
            var file = e.File;
            if (file == null)
            {
                return;
            }

            // Validate file size (max 10MB)
            const long maxFileSize = 10 * 1024 * 1024;
            if (file.Size > maxFileSize)
            {
                errorMessage = "File size exceeds 10MB limit";
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Validate file type
            if (!file.ContentType.StartsWith("image/"))
            {
                errorMessage = "Please select an image file";
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Read file and convert to base64
            using var stream = file.OpenReadStream(maxFileSize);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var bytes = memoryStream.ToArray();
            sourceImageBase64 = Convert.ToBase64String(bytes);

            // Clear previous results and reset job ID for new image
            preprocessedImageBase64 = null;
            ocrResult = null;
            inferenceResult = null;
            currentPhase = ProcessingPhase.Preprocessing;
            currentJobId = null;
            currentJobStatus = null;

            // Trigger preprocessing
            OnSettingsChanged();

            Logger.LogInformation("Image selected: {FileName}, {Size} bytes", file.Name, file.Size);
        }
        catch (Exception ex)
        {
            errorMessage = $"Error reading file: {ex.Message}";
            Logger.LogError(ex, "Error reading file");
        }

        await InvokeAsync(StateHasChanged);
    }

    private void OnSettingsChanged()
    {
        if (string.IsNullOrEmpty(sourceImageBase64))
            return;

        lastSettingsChange = DateTime.UtcNow;
        ResetTimer();
        StartTimer();
    }

    private void StartTimer()
    {
        timerActive = true;
        timerSecondsRemaining = 5;
        timerProgress = 100;

        updateTimer?.Stop();
        updateTimer = new System.Timers.Timer(5000);
        updateTimer.Elapsed += async (s, e) => await OnTimerElapsed();
        updateTimer.AutoReset = false;
        updateTimer.Start();

        progressTimer?.Stop();
        progressTimer = new System.Timers.Timer(200);
        progressTimer.Elapsed += OnProgressTick;
        progressTimer.AutoReset = true;
        progressTimer.Start();

        InvokeAsync(StateHasChanged);
    }

    private void ResetTimer()
    {
        updateTimer?.Stop();
        progressTimer?.Stop();
        timerActive = false;
        timerSecondsRemaining = 5;
        timerProgress = 100;
    }

    private void StartStatusPolling()
    {
        statusPollTimer?.Stop();
        if (string.IsNullOrEmpty(currentJobId)) return;

        statusPollTimer = new System.Timers.Timer(3000);
        statusPollTimer.Elapsed += async (s, e) => await PollJobStatus();
        statusPollTimer.AutoReset = true;
        statusPollTimer.Start();
    }

    private void StopStatusPolling()
    {
        statusPollTimer?.Stop();
    }

    private async Task PollJobStatus()
    {
        if (string.IsNullOrEmpty(currentJobId)) return;
        try
        {
            var status = await DocumentProcessingClient.GetJobStatusAsync(currentJobId);
            if (status != null)
            {
                currentJobStatus = status;
                await OnJobStatusChanged.InvokeAsync(status);
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to poll job status for {JobId}", currentJobId);
        }
    }

    private void OnProgressTick(object? sender, ElapsedEventArgs e)
    {
        var elapsed = (DateTime.UtcNow - lastSettingsChange).TotalSeconds;
        timerSecondsRemaining = Math.Max(0, (int)Math.Ceiling(5 - elapsed));
        timerProgress = Math.Max(0, (5 - elapsed) / 5 * 100);
        InvokeAsync(StateHasChanged);
    }

    private async Task OnTimerElapsed()
    {
        ResetTimer();
        await InvokeAsync(async () =>
        {
            if (currentPhase == ProcessingPhase.Preprocessing)
            {
                await RunPreprocessing();
            }
        });
    }

    private async Task RunPreprocessing()
    {
        if (string.IsNullOrEmpty(sourceImageBase64))
            return;

        isLoading = true;
        errorMessage = null;
        // Create job ID only if it doesn't exist (on first run for this image)
        if (string.IsNullOrEmpty(currentJobId))
        {
            currentJobId = Guid.NewGuid().ToString();
        }
        currentJobStatus = null;
        StartStatusPolling();
        await OnPreprocessingStarted.InvokeAsync(currentJobId);
        await InvokeAsync(StateHasChanged);

        try
        {
            var request = new PreprocessingRequest
            {
                ImageBase64 = sourceImageBase64,
                JobId = currentJobId,
                Denoise = settings.Denoise,
                Deskew = settings.Deskew,
                FuzzPercent = settings.FuzzPercent,
                DeskewThreshold = settings.DeskewThreshold,
                ContrastType = settings.ContrastType,
                ContrastStrength = settings.ContrastStrength,
                ContrastMidpoint = settings.ContrastMidpoint,
                ApplyThreshold = settings.ApplyThreshold,
                ThresholdPercent = settings.ThresholdPercent
            };

            var result = await DocumentProcessingClient.PreprocessImageAsync(request);

            if (result != null && result.Status == "done")
            {
                preprocessedImageBase64 = result.ImageBase64;
                Logger.LogInformation("Preprocessing complete for job {JobId}", currentJobId);
                await OnPreprocessingCompleted.InvokeAsync(result);
            }
            else
            {
                errorMessage = result?.Error ?? "Preprocessing failed";
                Logger.LogWarning("Preprocessing failed: {Error}", errorMessage);
                await OnError.InvokeAsync(errorMessage);
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Error during preprocessing: {ex.Message}";
            Logger.LogError(ex, "Error during preprocessing");
            await OnError.InvokeAsync(errorMessage);
        }
        finally
        {
            isLoading = false;
            StopStatusPolling();
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task AcceptPreprocessing()
    {
        currentPhase = ProcessingPhase.Ocr;
        await RunOcr();
    }

    private async Task RunOcr()
    {
        if (string.IsNullOrEmpty(preprocessedImageBase64))
            return;

        isLoading = true;
        errorMessage = null;
        // Reuse the same job ID from preprocessing for consistency
        if (string.IsNullOrEmpty(currentJobId))
        {
            currentJobId = Guid.NewGuid().ToString();
        }
        currentJobStatus = null;
        StartStatusPolling();
        await OnOcrStarted.InvokeAsync(currentJobId);
        await InvokeAsync(StateHasChanged);

        try
        {
            // Run OCR
            var ocrRequest = new OcrRequest
            {
                ImageBase64 = preprocessedImageBase64,
                JobId = currentJobId,
                OcrEngine = ocrSettings.OcrEngine,
                TargetDpi = ocrSettings.TargetDpi,
                Device = ocrSettings.Device
            };

            ocrResult = await DocumentProcessingClient.RunOcrAsync(ocrRequest);

            if (ocrResult == null || ocrResult.Status != "done")
            {
                errorMessage = ocrResult?.Error ?? "OCR failed";
                await OnError.InvokeAsync(errorMessage);
                return;
            }

            Logger.LogInformation("OCR complete for job {JobId}, detected {WordCount} words",
                currentJobId, ocrResult.Words?.Count ?? 0);
            await OnOcrCompleted.InvokeAsync(ocrResult);
        }
        catch (Exception ex)
        {
            errorMessage = $"Error during OCR: {ex.Message}";
            Logger.LogError(ex, "Error during OCR");
            await OnError.InvokeAsync(errorMessage);
        }
        finally
        {
            isLoading = false;
            StopStatusPolling();
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task AcceptOcr()
    {
        currentPhase = ProcessingPhase.Inference;
        await RunInference();
    }
    
    private async Task RunInference()
    {
        if (ocrResult == null || string.IsNullOrEmpty(preprocessedImageBase64))
            return;

        isLoading = true;
        errorMessage = null;
        // Reuse the same job ID from preprocessing/OCR for consistency
        if (string.IsNullOrEmpty(currentJobId))
        {
            currentJobId = Guid.NewGuid().ToString();
        }
        currentJobStatus = null;
        StartStatusPolling();
        await OnInferenceStarted.InvokeAsync(currentJobId);
        await InvokeAsync(StateHasChanged);

        try
        {
            // Run Inference
            var inferenceRequest = new InferenceRequest
            {
                OcrResult = ocrResult,
                ImageBase64 = preprocessedImageBase64,
                JobId = currentJobId,
                Model = inferenceSettings.Model,
                Device = inferenceSettings.Device
            };

            inferenceResult = await DocumentProcessingClient.RunInferenceAsync(inferenceRequest);

            if (inferenceResult == null || inferenceResult.Status != "done")
            {
                errorMessage = inferenceResult?.Error ?? "Inference failed";
                await OnError.InvokeAsync(errorMessage);
                return;
            }

            Logger.LogInformation("Inference complete for job {JobId}", currentJobId);
            await OnInferenceCompleted.InvokeAsync(inferenceResult);
        }
        catch (Exception ex)
        {
            errorMessage = $"Error during inference: {ex.Message}";
            Logger.LogError(ex, "Error during inference");
            await OnError.InvokeAsync(errorMessage);
        }
        finally
        {
            isLoading = false;
            StopStatusPolling();
            await InvokeAsync(StateHasChanged);
        }
    }

    private void GoBack()
    {
        if (currentPhase == ProcessingPhase.Inference)
        {
            // Go back from inference to OCR
            currentPhase = ProcessingPhase.Ocr;
            inferenceResult = null;
            StateHasChanged();
        }
        else if (currentPhase == ProcessingPhase.Ocr)
        {
            // Go back from OCR to preprocessing
            currentPhase = ProcessingPhase.Preprocessing;
            ocrResult = null;
            inferenceResult = null;

            // Only trigger preprocessing if we don't have a result yet
            if (string.IsNullOrEmpty(preprocessedImageBase64))
            {
                OnSettingsChanged();
            }
            else
            {
                // Just switch view without re-running preprocessing
                StateHasChanged();
            }
        }
    }

    private void Reset()
    {
        ResetTimer();
        StopStatusPolling();
        sourceImageBase64 = null;
        preprocessedImageBase64 = null;
        ocrResult = null;
        inferenceResult = null;
        errorMessage = null;
        currentPhase = ProcessingPhase.Preprocessing;
        currentJobId = null;
        currentJobStatus = null;
        settings = new PreprocessingSettings();
        ocrSettings = new OcrSettings();
        inferenceSettings = new InferenceSettings();
        StateHasChanged();
    }

    private async Task AcceptResult()
    {
        if (inferenceResult != null)
        {
            await OnResultAccepted.InvokeAsync(inferenceResult);
        }
    }

    private void ReplaceSourceWithPreprocessed()
    {
        if (!string.IsNullOrEmpty(preprocessedImageBase64))
        {
            // Replace source with last preprocessed result to allow stacking
            sourceImageBase64 = preprocessedImageBase64;
            // Clear current preprocessed result to show updated preview after re-run
            preprocessedImageBase64 = null;
            ocrResult = null;
            inferenceResult = null;
            currentPhase = ProcessingPhase.Preprocessing;
            OnSettingsChanged();
        }
    }

    // Magnifier helpers
    private void ShowMagnifier(bool isLeft)
    {
        if (isLeft)
        {
            leftLensVisible = true;
            // set display via JS-less by toggling style
            _ = InvokeAsync(async () =>
            {
                await Task.Delay(0);
                await UpdateLensDisplay(isLeft);
            });
        }
        else
        {
            rightLensVisible = true;
            _ = InvokeAsync(async () =>
            {
                await Task.Delay(0);
                await UpdateLensDisplay(isLeft);
            });
        }
    }

    private void HideMagnifier(bool isLeft)
    {
        if (isLeft) leftLensVisible = false; else rightLensVisible = false;
        _ = InvokeAsync(async () =>
        {
            await Task.Delay(0);
            await UpdateLensDisplay(isLeft);
        });
    }

    private async Task UpdateLensDisplay(bool isLeft)
    {
        var lens = isLeft ? leftLensRef : rightLensRef;
        // We cannot set style directly on ElementReference in Blazor Server/WASM without JS.
        // Use conditional rendering via CSS classes: display when visible.
        await InvokeAsync(StateHasChanged);
    }

    private void OnMagnifierMove(MouseEventArgs e, bool isLeft)
    {
        var lens = isLeft ? leftLensRef : rightLensRef;
        var img = isLeft ? leftImageRef : rightImageRef;
        var visible = isLeft ? leftLensVisible : rightLensVisible;
        if (!visible) return;

        // We adjust lens via inline styles using a backing dictionary since ElementReference needs JS to set styles.
        // Instead, compute coordinates and bind them to style strings.
        var posX = e.OffsetX;
        var posY = e.OffsetY;
        var lensSize = 160; // match CSS

        if (isLeft)
        {
            leftLensStyle = BuildLensStyle(posX, posY, lensSize, ((currentPhase == ProcessingPhase.Ocr || currentPhase == ProcessingPhase.Inference) && !string.IsNullOrEmpty(preprocessedImageBase64) ? preprocessedImageBase64 : sourceImageBase64));
        }
        else
        {
            rightLensStyle = BuildLensStyle(posX, posY, lensSize, preprocessedImageBase64);
        }

        InvokeAsync(StateHasChanged);
    }

    private string BuildLensStyle(double mouseX, double mouseY, int lensSize, string? base64)
    {
        if (string.IsNullOrEmpty(base64)) return "display:none;";
        var half = lensSize / 2.0;
        var bgPosX = mouseX;
        var bgPosY = mouseY;
        // Place lens centered on cursor. Use transform to center via left/top.
        return $"display:block; left:{mouseX - half}px; top:{mouseY - half}px; background-image:url('data:image/png;base64,{base64}'); background-position:{bgPosX}px {bgPosY}px;";
    }

    private string leftLensStyle = "display:none;";
    private string rightLensStyle = "display:none;";

    public void Dispose()
    {
        updateTimer?.Dispose();
        progressTimer?.Dispose();
        statusPollTimer?.Dispose();
    }

    // Settings classes
    private class PreprocessingSettings
    {
        public bool Denoise { get; set; } = false;
        public bool Deskew { get; set; } = true;
        public int FuzzPercent { get; set; } = 30;
        public int DeskewThreshold { get; set; } = 40;
        public string ContrastType { get; set; } = "sigmoidal";
        public double ContrastStrength { get; set; } = 3.0;
        public int ContrastMidpoint { get; set; } = 120;
        public bool ApplyThreshold { get; set; } = false;
        public int ThresholdPercent { get; set; } = 50;
    }
    
    private class OcrSettings
    {
        public string OcrEngine { get; set; } = "tesseract";
        public int TargetDpi { get; set; } = 300;
        public string Device { get; set; } = "auto";
    }
    
    private class InferenceSettings
    {
        public string Model { get; set; } = "naver-clova-ix/donut-base-finetuned-cord-v2";
        public string Device { get; set; } = "auto";
    }
}
